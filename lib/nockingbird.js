// Generated by CoffeeScript 1.8.0
(function() {
  var R, fs, is_method_name, path,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  R = require('ramda');

  is_method_name = R.rPartial(R.contains, ['GET', 'POST', 'PUT', 'HEAD', 'PATCH', 'MERGE', 'DELETE']);

  exports.mock = function(scope, chunk, root) {
    var filename, method_name, other_response_lines, pathname, request_lines, response_body_lines, response_header_lines, response_lines, status_code_line, _ref, _ref1;
    request_lines = [];
    response_lines = [];
    chunk.replace(/\n+$/, '').split(/\n/).map(RegExp.prototype.exec.bind(/^(>>|<<)\s*(.*)$/)).forEach(function(match) {
      if (match === null) {
        throw new SyntaxError('Invalid chunk (lines must begin with ">>" or "<<")');
      } else {
        return (match[1] === '>>' ? request_lines : response_lines).push(match[2]);
      }
    });
    _ref = request_lines[0].split(/[ ]+/), method_name = _ref[0], pathname = _ref[1];
    if (!is_method_name(method_name)) {
      throw new Error("Invalid request method \"" + method_name + "\"");
    }
    status_code_line = response_lines[0], other_response_lines = 2 <= response_lines.length ? __slice.call(response_lines, 1) : [];
    _ref1 = other_response_lines.reduce(function(_arg, line, idx) {
      var body_lines, header_lines, match;
      header_lines = _arg[0], body_lines = _arg[1];
      if (match = /^=(.*)$/.exec(line)) {
        return [header_lines, __slice.call(body_lines).concat([match[1]])];
      } else if (idx === other_response_lines.length - 1) {
        return [header_lines, body_lines, line];
      } else {
        return [__slice.call(header_lines).concat([line]), body_lines];
      }
    }, [[], []]), response_header_lines = _ref1[0], response_body_lines = _ref1[1], filename = _ref1[2];
    scope[method_name.toLowerCase()].apply(scope, R.pipe(R.tail, R.map(RegExp.prototype.exec.bind(/^=(.*)$/)), R.pluck('1'), R.join('\n'), R.of, R.reject(R.isEmpty), R.concat([pathname]))(request_lines))[filename != null ? 'replyWithFile' : 'reply'](Number(status_code_line), filename != null ? path.resolve(root, filename) : response_body_lines.join('\n'), R.pipe(R.map(RegExp.prototype.exec.bind(/^([^:]*):[ ]*(.*)$/)), R.map(R.tail), R.fromPairs)(response_header_lines));
  };

  exports.load = function(scope, filename, root) {
    fs.readFileSync(filename, 'utf8').replace(/^\s*--.*$\n?/gm, '').split(/\n{2,}/).filter(Boolean).forEach(function(chunk) {
      return exports.mock(scope, chunk, root);
    });
  };

}).call(this);
